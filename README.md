# Padel Bot — профессиональная документация проекта

Этот README является полным, структурированным и профессионально оформленным руководством по архитектуре, работе, развёртыванию и поддержке Padel Bot — системы бронирования падел‑кортов, функционирующей на базе Telegram Webhook, FastAPI, Redis и Render.

---

## 1. Назначение и возможности бота

**Padel Bot** — это автоматизированная система, позволяющая пользователям резервировать падел‑корт через Telegram. Бот обеспечивает:

- выбор дня (сегодня / завтра);
- выбор доступных временных слотов;
- запрет записи в период сиесты;
- запись данных пользователя (имя, квартира);
- хранение бронирований в Redis (устойчиво к перезапускам);
- автоматические уведомления о каждой брони в групповом чате;
- возможность отмены своих бронирований;
- безопасную и стабильную доставку событий через Webhook.

Бот оптимизирован специально для стабильной работы на **Render Free Tier**, включая защиту от ложных падений и корректную работу при холодных стартах.

---

## 2. Технологический стек

| Компонент | Назначение |
|----------|------------|
| **Python 3.11+** | Язык разработки |
| **python‑telegram‑bot >= 20.0** | Telegram Webhook API |
| **FastAPI** | HTTP‑сервер, endpoint `/health`, webhook |
| **Uvicorn** | ASGI‑сервер |
| **Redis (Upstash)** | Постоянное хранилище бронирований |
| **Render Web Service** | Хостинг приложения |
| **UptimeRobot** | Мониторинг + "keep‑alive" |

Стек подобран так, чтобы минимизировать задержки cold‑start, исключить polling, и обеспечить сохранность данных.

---

## 3. Архитектура проекта

Минимальная структура:
```
padel-bot/
├── main.py               # Основная логика бота и FastAPI
├── requirements.txt      # Список зависимостей
└── README.md             # Данный документ
```

**Основные компоненты системы:**

1. **Telegram Webhook** → Получение событий от Telegram.
2. **FastAPI** → Обработка HTTP‑запросов и объединение с Telegram Application.
3. **Redis** → Хранение бронирований в формате ключей `booking:<дата>:<таймслот>`.
4. **UptimeRobot** → Периодические HEAD‑запросы на `/health` для:
   - поддержания Render в активном состоянии,
   - своевременного оповещения об ошибках.

---

## 4. Переменные окружения (Render)

Следующие переменные должны быть заданы в Render → Environment:

| Переменная | Описание |
|-----------|----------|
| `BOT_TOKEN` | Токен Telegram бота |
| `GROUP_CHAT_ID` | ID группового чата для уведомлений |
| `REDIS_URL` | URL Upstash Redis |
| `BASE_URL` | URL Render сервиса, например `https://padel-bot.onrender.com` |
| `WEBHOOK_SECRET` | Секретный ключ для пути вебхука |

---

## 5. Установка зависимостей

Содержимое `requirements.txt`:
```
python-telegram-bot>=20.0
pytz
redis>=5.0
fastapi
uvicorn[standard]
```

---

## 6. Запуск и развёртывание на Render

Render Web Service конфигурируется следующим стартовым командой:
```
uvicorn main:app --host 0.0.0.0 --port $PORT
```

При запуске приложение выполняет:
1. Подключение к Redis.
2. Очистку старых бронирований.
3. Инициализацию Telegram Application.
4. Установку вебхука по адресу вида:
```
https://<BASE_URL>/webhook/<WEBHOOK_SECRET>
```

Webhook принимает POST‑запросы от Telegram и обрабатывает события мгновенно.

---

## 7. Хранение данных в Redis

**Структура ключей:**
```
booking:<дата>:<таймслот>
```
Пример:
```
booking:16/11/2025:10:00–11:30
```

**Записывается JSON:**
```
{
  "username": <имя или ник>,
  "piso": <квартира>,
  "name": <имя для отображения>
}
```

**Особенности:**
- Создание происходит через `SET ... NX`, что исключает двойные бронирования.
- Бронь принадлежит пользователю, который её создал.
- Авто‑очистка выполняется при каждом старте.

---

## 8. Состояние диалога (FSM)

Состояние диалога пользователя хранится в `context.user_data`.

Используемые ключи:
- `day`
- `time`
- `floor`
- `name`
- `cancel_options`

Состояние очищается при `/start`, начале новой операции или после завершения.

Глобальные переменные **не используются** — только Redis + user_data.

---

## 9. FastAPI эндпоинты

Эндпоинты находятся в конце `main.py`.

### Корневой эндпоинт
```
/
```
Возвращает `OK` для HEAD и GET.

### Health‑check
```
/health
```
Используется UptimeRobot. Всегда отдаёт `200 OK`. Не содержит тяжёлой логики.

### Webhook
```
/webhook/<WEBHOOK_SECRET>
```
Принимает POST от Telegram.

---

## 10. Мониторинг UptimeRobot

UptimeRobot обеспечивает:
- уведомления о реальных сбоях,
- поддержание Render в активном состоянии (без засыпания),
- защиту от cold‑start задержек.

**Настройки монитора:**
- **Type:** HTTPS
- **URL:** `<BASE_URL>/health`
- **Interval:** каждые 5 минут (минимум на free‑тарифе)
- **Timeout:** 60 секунд
- **Method:** HEAD

HEAD‑метод специально разрешён в `/health` для 100% совместимости.

---

## 11. Чего не следует делать

Чтобы сохранить стабильность:

1. **Не использовать polling** — только Webhook.
2. **Не хранить данные в файлах** — только Redis.
3. **Не добавлять тяжёлую логику в `/health`**.
4. **Не отключать UptimeRobot**, если нужны уведомления.
5. **Не менять `drop_pending_updates=False`** при установке webhook.

---

## 12. Расширение функциональности

Можно безопасно добавлять:
- команды (`/list`, `/admin`, `/stats`),
- вывод всех броней из Redis,
- фильтры и поиск,
- административные действия,
- новые клавиатуры.

Главное — не менять базовые механизмы:
- структуру Redis,
- FastAPI эндпоинты,
- установку Webhook.

---

## 13. Статус и надёжность системы

После всех оптимизаций система обеспечивает:
- мгновенную обработку событий Telegram через Webhook;
- устойчивость к холодным стартам Render;
- постоянную активность благодаря UptimeRobot;
- корректный health‑check без ложных срабатываний;
- 100% сохранность бронирований в Redis;
- отсутствие конфликтов при одновременных бронированиях.

Система полностью готова к эксплуатации.

---

Если в будущем произойдут архитектурные изменения, они должны быть добавлены в данный README.

